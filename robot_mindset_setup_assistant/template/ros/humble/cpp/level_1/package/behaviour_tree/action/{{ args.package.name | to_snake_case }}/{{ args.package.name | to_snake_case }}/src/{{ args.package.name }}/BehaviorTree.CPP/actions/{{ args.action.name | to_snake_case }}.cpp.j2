{% set identifier = (action.id or action.name or action.class_name) | default('ActionNode', true) %}
{% set class_name = action.class_name | default(identifier | to_pascal_case) %}
{% set base_class = action.base_class | default('SyncActionNode') %}
{% set input_ports = action.ports.inputs | default([], true) %}
{% set output_ports = action.ports.outputs | default([], true) %}

#include "{{ args.package.name | to_snake_case }}/BehaviorTree.CPP/actions/{{ args.action.name | to_snake_case }}.hpp"


namespace {{ args.package.name | to_snake_case }}::bt::actions {

{{ class_name }}::{{ class_name }}(const std::string &name, const BT::NodeConfiguration &config)
    : BT::{{ base_class }}(name, config) {}

BT::PortsList {{ class_name }}::providedPorts()
{
  using namespace BT;
  return {
{% for port in input_ports %}
    InputPort<{{ port.type | default('double') }}>("{{ port.name }}"{% if port.default is defined %}, {{ port.default }}{% endif %}, "{{ port.description | default('Input port') }}"),
{% endfor %}
{% for port in output_ports %}
    OutputPort<{{ port.type | default('double') }}>("{{ port.name }}", "{{ port.description | default('Output port') }}"),
{% endfor %}
  };
}

{% if base_class == 'StatefulActionNode' %}
BT::NodeStatus {{ class_name }}::onStart()
{
{% for port in input_ports %}
  {% set variable_name = port.variable | default(port.name | to_snake_case, true) | default('input_' ~ loop.index0, true) %}
  const auto {{ variable_name }} = getInput<{{ port.type | default('double') }}>("{{ port.name }}");
  if (!{{ variable_name }})
  {
    throw BT::RuntimeError(fmt::format("[{{ class_name }}] missing required input [{}]: {}", "{{ port.name }}", {{ variable_name }}.error()));
  }
{% endfor %}

  // TODO: implement onStart behavior

  return BT::NodeStatus::RUNNING;
}

BT::NodeStatus {{ class_name }}::onRunning()
{
  // TODO: implement stateful running behavior
  return BT::NodeStatus::SUCCESS;
}

void {{ class_name }}::onHalted()
{
  // TODO: handle cleanup when the node is halted
}
{% elif base_class == 'AsyncActionNode' %}
BT::NodeStatus {{ class_name }}::tick()
{
{% for port in input_ports %}
  {% set variable_name = port.variable | default(port.name | to_snake_case, true) | default('input_' ~ loop.index0, true) %}
  const auto {{ variable_name }} = getInput<{{ port.type | default('double') }}>("{{ port.name }}");
  if (!{{ variable_name }})
  {
    throw BT::RuntimeError(fmt::format("[{{ class_name }}] missing required input [{}]: {}", "{{ port.name }}", {{ variable_name }}.error()));
  }
{% endfor %}

  // TODO: launch asynchronous work and report status

  return BT::NodeStatus::SUCCESS;
}

void {{ class_name }}::halt()
{
  // TODO: cancel outstanding asynchronous work if needed
}
{% else %}
BT::NodeStatus {{ class_name }}::tick()
{
{% for port in input_ports %}
  {% set variable_name = port.variable | default(port.name | to_snake_case, true) | default('input_' ~ loop.index0, true) %}
  const auto {{ variable_name }} = getInput<{{ port.type | default('double') }}>("{{ port.name }}");
  if (!{{ variable_name }})
  {
    throw BT::RuntimeError(fmt::format("[{{ class_name }}] missing required input [{}]: {}", "{{ port.name }}", {{ variable_name }}.error()));
  }
{% endfor %}

  // TODO: implement synchronous action logic

{% for port in output_ports %}
  {% set placeholder_value = port.placeholder | default(default_output_placeholder(port.type | default('double')), true) %}
  setOutput<{{ port.type | default('double') }}>("{{ port.name }}", {{ placeholder_value }});
{% endfor %}

  return BT::NodeStatus::SUCCESS;
}
{% endif %}

}  // namespace {{ args.package.name | to_snake_case }}::bt::actions

