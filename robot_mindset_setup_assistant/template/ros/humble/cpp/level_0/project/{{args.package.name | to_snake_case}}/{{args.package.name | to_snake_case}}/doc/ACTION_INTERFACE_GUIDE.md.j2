# ROS Action Server & Client Interface Guide

This document describes how to implement and use ROS action servers and clients in the {{ args.package.name }} package.

## Architecture Overview

This package follows a clean architecture pattern that separates ROS infrastructure from business logic:

- **ROS Node** (`ros_node.cpp`): Handles ROS-specific concerns (goal handling, cancellation, feedback publishing)
- **LogicModule** (`{{ args.package.name }}.cpp`): Contains business logic for action execution and client triggering

## Action Servers

Action servers provide services that can be called by other nodes to perform long-running tasks.

### Available Action Servers

{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "out" %}
{%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
{%- set lu = args.lookup.interfaces.msgs[interface.msgs] %}

#### {{ interface.name }}
- **Description**: {{ interface.description }}
- **Action Type**: `{{ lu.ros_data_type }}`
- **Topic**: `/{{ args.package.name }}/{{ interface.name }}`
- **Implementation Method**: `LogicModule::execute_action_{{ interface.name|to_snake_case }}()`

{%- endif %}
{%- endfor %}
{%- else %}

*No action servers defined in this package.*

{%- endif %}

### Implementing Action Server Logic

Action server business logic is implemented in the `LogicModule` class. Each action server has a corresponding `execute_action_*()` method.

#### Method Signature

```cpp
void execute_action_<name>(
    const std::shared_ptr<const ActionType::Goal> goal,        // Input parameters
    std::shared_ptr<ActionType::Feedback> feedback,           // Progress updates  
    std::shared_ptr<ActionType::Result> result,               // Final result
    std::function<bool()> is_canceling,                       // Check cancellation
    std::function<void(std::shared_ptr<Feedback>)> publish_feedback, // Send feedback
    std::function<bool()> is_ok                               // Check ROS status
);
```

#### Implementation Guidelines

1. **Check for cancellation regularly**:
   ```cpp
   if (is_canceling()) {
       spdlog::info("Action was canceled");
       return; // Exit early
   }
   ```

2. **Publish feedback for long-running operations**:
   ```cpp
   feedback->progress = current_progress;
   publish_feedback(feedback);
   ```

3. **Use is_ok() in loops**:
   ```cpp
   while (condition && is_ok()) {
       // Do work...
       if (is_canceling()) break;
   }
   ```

4. **Set result before returning**:
   ```cpp
   result->final_value = computed_result;
   result->success = true;
   ```

5. **Use JINJA preservation tags** to preserve your custom implementation:
   ```cpp
   // JINJA-BEGIN:action-name_execute_action_implementation
   // Your custom implementation here
   // JINJA-END:action-name_execute_action_implementation
   ```

#### Example Implementation

```cpp
void LogicModule::execute_action_my_action(
    const std::shared_ptr<const MyAction::Goal> goal,
    std::shared_ptr<MyAction::Feedback> feedback,
    std::shared_ptr<MyAction::Result> result,
    std::function<bool()> is_canceling,
    std::function<void(std::shared_ptr<MyAction::Feedback>)> publish_feedback,
    std::function<bool()> is_ok) {
    
    // Extract goal parameters
    int target = goal->target_value;
    
    // Perform work with progress updates
    for (int i = 0; i < target && is_ok(); ++i) {
        if (is_canceling()) {
            spdlog::info("Action canceled at step {}", i);
            return;
        }
        
        // Simulate work
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        // Update progress
        feedback->current_value = i;
        feedback->progress_percentage = (float)i / target * 100.0f;
        publish_feedback(feedback);
    }
    
    // Set final result
    result->final_value = target;
    result->success = true;
}
```

## Action Clients

Action clients allow your node to call action servers provided by other nodes.

### Available Action Clients

{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "in" %}
{%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
{%- set lu = args.lookup.interfaces.msgs[interface.msgs] %}

#### {{ interface.name }}
- **Description**: {{ interface.description }}
- **Action Type**: `{{ lu.ros_data_type }}`
- **Topic**: `/{{ interface.name }}`
- **Trigger Method**: `LogicModule::interface_act_{{ interface.name|to_snake_case }}()`
- **Callback Methods**:
  - `goal_response_callback_{{ interface.name|to_snake_case }}()`
  - `feedback_callback_{{ interface.name|to_snake_case }}()`
  - `result_callback_{{ interface.name|to_snake_case }}()`

{%- endif %}
{%- endfor %}
{%- else %}

*No action clients defined in this package.*

{%- endif %}

### Using Action Clients

#### 1. Trigger Action Client

Call the interface method from your business logic:

```cpp
// In your LogicModule business logic
int goal_parameter = 42;
interface_act_my_action_client(goal_parameter);
```

#### 2. Handle Responses (Override Callback Methods)

Override the virtual callback methods in `LogicModuleInputInterface`:

```cpp
// In your LogicModule class

// Called when goal is accepted/rejected by server
void goal_response_callback_my_action_client(
    const rclcpp_action::ClientGoalHandle<MyAction>::SharedPtr & goal_handle) override {
    if (goal_handle) {
        spdlog::info("Goal accepted by server");
    } else {
        spdlog::warn("Goal rejected by server");
    }
}

// Called when feedback is received from server
void feedback_callback_my_action_client(
    rclcpp_action::ClientGoalHandle<MyAction>::SharedPtr goal_handle,
    const std::shared_ptr<const MyAction::Feedback> feedback) override {
    spdlog::info("Received feedback: progress = {}", feedback->progress_percentage);
}

// Called when final result is received
void result_callback_my_action_client(
    const rclcpp_action::ClientGoalHandle<MyAction>::WrappedResult & result) override {
    switch (result.code) {
        case rclcpp_action::ResultCode::SUCCEEDED:
            spdlog::info("Action succeeded: final_value = {}", result.result->final_value);
            break;
        case rclcpp_action::ResultCode::CANCELED:
            spdlog::warn("Action was canceled");
            break;
        case rclcpp_action::ResultCode::ABORTED:
            spdlog::error("Action aborted");
            break;
    }
}
```

## Testing Actions

### Testing Action Servers

Use the `ros2 action` command-line tool:

```bash
# List available actions
ros2 action list

# Send a goal to an action server
ros2 action send_goal /{{ args.package.name }}/my_action MyAction "goal_parameter: 42" --feedback

# Get action info
ros2 action info /{{ args.package.name }}/my_action
```

### Testing Action Clients

1. Start an external action server that provides the service your client needs
2. Trigger your action client through your business logic
3. Monitor logs to see the callback responses

## Best Practices

### Action Servers

1. **Always check for cancellation** in long-running operations
2. **Publish feedback regularly** to keep clients informed
3. **Set meaningful result values** before completing
4. **Handle errors gracefully** and log appropriately
5. **Use preservation tags** to maintain custom code during regeneration
6. **Keep business logic in LogicModule**, not in ROS node

### Action Clients

1. **Handle all response types** (success, canceled, aborted)
2. **Implement proper error handling** in callbacks
3. **Don't block in callback methods** - they run in ROS executor threads
4. **Store state if needed** for coordination between callbacks
5. **Log meaningful information** for debugging

### General

1. **Separate concerns**: ROS infrastructure vs. business logic
2. **Use spdlog for logging** instead of ROS logging in LogicModule
3. **Make methods testable** by avoiding direct ROS dependencies in LogicModule
4. **Document your action interfaces** and expected behaviors
5. **Version your action message definitions** carefully

## Debugging

### Common Issues

1. **Action server not available**: Check if the target action server is running
2. **Goals not being accepted**: Check goal validation logic in action server
3. **No feedback received**: Ensure `publish_feedback()` is called regularly
4. **Action hangs**: Check for infinite loops without cancellation checks
5. **Callbacks not called**: Verify action client is properly connected

### Useful Commands

```bash
# Monitor action activity
ros2 topic echo /my_action/_action/status

# Check action server status
ros2 node info /my_node

# Debug action messages
ros2 interface show MyAction
```

---

*This guide is automatically generated based on your package configuration. Modify the action interfaces in your setup assistant configuration to update this documentation.*