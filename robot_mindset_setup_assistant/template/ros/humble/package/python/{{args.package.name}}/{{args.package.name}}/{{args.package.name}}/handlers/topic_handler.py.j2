"""Topic handler implementing publish/subscribe business logic."""

from __future__ import annotations

from typing import Any, Callable, Optional

from loguru import logger


class TopicHandler:
    """Encapsulates topic-specific business logic independent from ROS."""

    def __init__(self) -> None:
        logger.debug("TopicHandler initialised")
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "out" %}
{%- set identifier = interface.name|regex_replace('[^A-Za-z0-9]', '_') %}
        self._publish_callback_{{ identifier }}: Optional[Callable[..., None]] = None
{%- endfor %}
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
{%- set identifier = interface.name|regex_replace('[^A-Za-z0-9]', '_') %}
        self._subscription_callback_{{ identifier }}: Optional[Callable[..., None]] = None
{%- endfor %}
{%- endif %}

    # ==================================================================
    # Publisher methods
    # ==================================================================
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "out" %}
{%- set identifier = interface.name|regex_replace('[^A-Za-z0-9]', '_') %}
{%- if interface.msgs in args.lookup.interfaces.msgs %}
{%- set lu = namespace(cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
    def set_publish_callback_{{ identifier }}(self, callback: Callable[[
{%- for field in lu.cpp_data_type %}
            Any,
{%- endfor %}
        ], None]) -> None:
        """Register ROS layer publish delegate for {{ interface.description }}.

        Args:
            callback: Callable invoked by the logic module to perform the actual
                ROS publish. Signature::

                    callback(
{%- for field in lu.cpp_data_type %}
                        {{ field.name }}: {{ field.type | replace('std::', '') }}{% if not loop.last %},
{%- endif %}
{%- endfor %}
                    )
        """
        self._publish_callback_{{ identifier }} = callback
        logger.debug("TopicHandler: registered publish callback for {{ interface.name }}")

    def publish_{{ identifier }}(
        self,
{%- for field in lu.cpp_data_type %}
        {{ field.name }}: Any,
{%- endfor %}
    ) -> None:
        """Publish processed data on topic {{ interface.name }}.

        Args:
{%- for field in lu.cpp_data_type %}
            {{ field.name }}: Processed value for ``{{ field.name }}`` (type: {{ field.type | replace('std::', '') }}).
{%- endfor %}
        """
        # JINJA-BEGIN:{{ interface.name|regex_replace('[^A-Za-z0-9]', '-') }}-publish-implementation
        logger.info("TopicHandler: Publishing to {{ interface.name }}")
        # TODO: Add your business logic for outgoing data
        # Example processing (replace with your logic):
{%- for field in lu.cpp_data_type %}
        # processed_{{ field.name }} = {{ field.name }}
{%- endfor %}
        # JINJA-END:{{ interface.name|regex_replace('[^A-Za-z0-9]', '-') }}-publish-implementation

        if self._publish_callback_{{ identifier }} is None:
            logger.warning("TopicHandler: No publish callback registered for {{ interface.name }}")
            return

        self._publish_callback_{{ identifier }}(
{%- for field in lu.cpp_data_type %}
            {{ field.name }},
{%- endfor %}
        )
{%- endif %}
{%- endfor %}
{%- endif %}

    # ==================================================================
    # Subscriber processing
    # ==================================================================
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
{%- if interface.msgs in args.lookup.interfaces.msgs %}
{%- set identifier = interface.name|regex_replace('[^A-Za-z0-9]', '_') %}
{%- set lu = namespace(cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
    def set_subscription_callback_{{ identifier }}(self, callback: Callable[[
{%- for field in lu.cpp_data_type %}
            Any,
{%- endfor %}
        ], None]) -> None:
        """Register optional delegate invoked after subscription processing.

        Args:
            callback: Callable executed with message field values after the
                logic handler processes the incoming data. Signature::

                    callback(
{%- for field in lu.cpp_data_type %}
                        msg_{{ field.name }}: {{ field.type | replace('std::', '') }}{% if not loop.last %},
{%- endif %}
{%- endfor %}
                    ) -> None
        """
        self._subscription_callback_{{ identifier }} = callback
        logger.debug("TopicHandler: registered subscription callback for {{ interface.name }}")

    def process_subscription_{{ identifier }}(
        self,
{%- for field in lu.cpp_data_type %}
        msg_{{ field.name }}: Any,
{%- endfor %}
    ) -> None:
        """Process incoming data from topic {{ interface.name }}.

        Args:
{%- for field in lu.cpp_data_type %}
            msg_{{ field.name }}: Value extracted from the incoming ROS message field
                ``{{ field.name }}`` (type: {{ field.type | replace('std::', '') }}).
{%- endfor %}
        """
        logger.info("TopicHandler: Received message on {{ interface.name }}")
        # JINJA-BEGIN:{{ interface.name|regex_replace('[^A-Za-z0-9]', '-') }}-subscription-implementation
{%- for field in lu.cpp_data_type %}
        logger.debug("\t{{ field.name }} = {}", msg_{{ field.name }})
{%- endfor %}
        # Add your custom processing logic here
        # JINJA-END:{{ interface.name|regex_replace('[^A-Za-z0-9]', '-') }}-subscription-implementation
        callback = self._subscription_callback_{{ identifier }}
        if callback is None:
            logger.warning("TopicHandler: No subscription callback registered for {{ interface.name }}")
            return

        try:
            callback(
{%- for field in lu.cpp_data_type %}
                msg_{{ field.name }},
{%- endfor %}
            )
        except Exception as exc:  # pragma: no cover - user callback safety
            logger.error("TopicHandler: Subscription callback for {{ interface.name }} raised exception: {}", exc)
{%- endif %}
{%- endfor %}
{%- endif %}
