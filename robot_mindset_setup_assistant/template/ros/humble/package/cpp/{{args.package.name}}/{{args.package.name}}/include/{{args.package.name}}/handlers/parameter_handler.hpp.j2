#pragma once

#include <string>
#include <functional>
#include <spdlog/spdlog.h>

/**
 * @file parameter_handler.hpp
 * @brief Parameter interface handler for runtime configuration
 * 
 * This class handles all parameter-related business logic, including:
 * - Processing parameter change callbacks
 * - Validating parameter values
 * - Applying parameter updates to business logic
 */

namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}} {

/**
 * @class ParameterHandler
 * @brief Handles all parameter-related business logic
 * 
 * This class encapsulates parameter-specific operations, providing a clean
 * interface for runtime configuration while maintaining separation from
 * ROS infrastructure concerns.
 */
class ParameterHandler {
public:
    ParameterHandler();
    virtual ~ParameterHandler() = default;

    // =============================================================================
    // PARAMETER CALLBACK METHODS
    // =============================================================================
    // These methods handle parameter change notifications
    
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "parameter" %}
    /**
     * @brief Process parameter change: {{ interface.name }}
     * @param new_value The new parameter value
     * 
     * Description: {{ interface.description }}
{%- if interface.data_type is defined %}
     * Parameter Type: {{ interface.data_type }}
{%- endif %}
{%- if interface.default_value is defined %}
     * Default Value: {{ interface.default_value }}
{%- endif %}
{%- if interface.min_value is defined and interface.max_value is defined %}
     * Value Range: {{ interface.min_value }} to {{ interface.max_value }}
{%- endif %}
     */
    void process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
{%- if interface.data_type == "string" %}
        const std::string& new_value);
{%- elif interface.data_type == "int" %}
        const int64_t& new_value);
{%- elif interface.data_type == "double" %}
        const double& new_value);
{%- elif interface.data_type == "bool" %}
        const bool& new_value);
{%- else %}
        const std::string& new_value);
{%- endif %}

{%- endfor %}
{%- endif %}

    // =============================================================================
    // PARAMETER VALIDATION METHODS
    // =============================================================================
    // These methods validate parameter values before applying them
    
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "parameter" %}
    /**
     * @brief Validate parameter value: {{ interface.name }}
     * @param value The parameter value to validate
     * @return true if valid, false otherwise
     */
    bool validate_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
{%- if interface.data_type == "string" %}
        const std::string& value) const;
{%- elif interface.data_type == "int" %}
        const int64_t& value) const;
{%- elif interface.data_type == "double" %}
        const double& value) const;
{%- elif interface.data_type == "bool" %}
        const bool& value) const;
{%- else %}
        const std::string& value) const;
{%- endif %}

{%- endfor %}
{%- endif %}

    // =============================================================================
    // PARAMETER ACCESS METHODS
    // =============================================================================
    // These methods provide access to current parameter values
    
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "parameter" %}
    /**
     * @brief Get current value of parameter: {{ interface.name }}
     * @return Current parameter value
     */
{%- if interface.data_type == "string" %}
    const std::string& get_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() const { return {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_; }
{%- elif interface.data_type == "int" %}
    int64_t get_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() const { return {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_; }
{%- elif interface.data_type == "double" %}
    double get_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() const { return {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_; }
{%- elif interface.data_type == "bool" %}
    bool get_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() const { return {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_; }
{%- else %}
    const std::string& get_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() const { return {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_; }
{%- endif %}

{%- endfor %}
{%- endif %}

private:
    // =============================================================================
    // PARAMETER STORAGE
    // =============================================================================
    // Current parameter values
    
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "parameter" %}
{%- if interface.data_type == "string" %}
    std::string {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_;
{%- elif interface.data_type == "int" %}
    int64_t {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_;
{%- elif interface.data_type == "double" %}
    double {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_;
{%- elif interface.data_type == "bool" %}
    bool {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_;
{%- else %}
    std::string {{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_;
{%- endif %}

{%- endfor %}
{%- endif %}
};

}  // namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}