#include <chrono>
#include <functional>
#include <memory>
#include <thread>
#include "ros/ros_node.hpp"
#include "ros/handlers/ros_topic_handler.hpp"
#include "ros/handlers/ros_service_handler.hpp"
#include "ros/handlers/ros_action_handler.hpp"
#include "ros/handlers/ros_parameter_handler.hpp"

namespace {{ args.package.name|regex_replace('[^A-Za-z0-9]', '_') }}
{

/****************** Constructor & Destructor ******************/
ROSNode::ROSNode() : Node("{{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}")
{
    // Initialize handler composition
    topic_handler_ = std::make_unique<RosTopicHandler>(this);
    service_handler_ = std::make_unique<RosServiceHandler>(this);
    action_handler_ = std::make_unique<RosActionHandler>(this);
    parameter_handler_ = std::make_unique<RosParameterHandler>(this);

    // Initialize handlers
    topic_handler_->initialize();
    service_handler_->initialize();
    action_handler_->initialize();
    parameter_handler_->initialize();

    // Delegate logic module setup if needed
    init_logic_module();
}

ROSNode::~ROSNode()
{
    // Shutdown handlers in reverse order
    if (action_handler_) action_handler_->shutdown();
    if (service_handler_) service_handler_->shutdown();
    if (topic_handler_) topic_handler_->shutdown();
    if (parameter_handler_) parameter_handler_->shutdown();
}

/****************** Initialization Functions ******************/
void ROSNode::init_parameters()
{
    // Delegate parameter initialization to handler
    if (parameter_handler_) {
        parameter_handler_->initialize();
    }
}

void ROSNode::init_ros_interface_subscribers()
{
    // Delegate subscriber initialization to topic handler
    if (topic_handler_) {
        topic_handler_->initialize();
    }
}
void ROSNode::init_ros_interface_publishers()
{
    // Delegate publisher initialization to topic handler
    if (topic_handler_) {
        topic_handler_->initialize();
    }
}
void ROSNode::init_ros_interface_services()
{
    // Delegate service server initialization to service handler
    if (service_handler_) {
        service_handler_->initialize();
    }
}
void ROSNode::init_ros_interface_clients()
{
    // Delegate service client initialization to service handler
    if (service_handler_) {
        service_handler_->initialize();
    }
}
void ROSNode::init_ros_interface_action_services()
{
        // Delegate action server initialization to action handler
        if (action_handler_) {
                action_handler_->initialize();
        }
}
void ROSNode::init_ros_interface_action_clients()
{
        // Delegate action client initialization to action handler
        if (action_handler_) {
                action_handler_->initialize();
        }
}
void ROSNode::init_logic_module()
{
    // === Connect Logic Module to ROS Handlers using Delegation Pattern ===
    
    // 1. TOPIC HANDLERS: Set up bidirectional communication between LogicModule and ROS
{%- if args.ros is defined %}
{%- if args.ros.interfaces is defined %}
    // Topic Publishers: LogicModule -> ROS handlers -> ROS network
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "out" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
    // Connect {{ interface.name }} publisher from LogicModule to ROS
    logic_module_.topic_handler().set_publish_callback_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
        [this](
        {%- for field in lu.cpp_data_type %}
        const {{ field.type }} &{{ field.name }}{% if not loop.last %}, {% endif %}
        {%- endfor %}) {
            if (topic_handler_) {
                topic_handler_->publish_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
                {%- for field in lu.cpp_data_type %}
                {{ field.name }}{% if not loop.last %}, {% endif %}
                {%- endfor %});
            }
        });
    {%- endif %}
{%- endfor %}
    
    // Topic Subscribers: ROS network -> ROS handlers -> LogicModule
{%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type,
                           cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
    // Connect {{ interface.name }} subscriber from ROS to LogicModule
    if (topic_handler_) {
        topic_handler_->set_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_callback(
            [this](
            {%- for field in lu.cpp_data_type %}
                const {{ field.type }} &{{ field.name }}{% if not loop.last %}, {% endif %}
            {%- endfor %}) {
                logic_module_.topic_handler().process_subscription_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
                {%- for field in lu.cpp_data_type %}
                {{ field.name }}{% if not loop.last %}, {% endif %}
                {%- endfor %});
            });
    }
    {%- endif %}
{%- endfor %}
    
    // 2. SERVICE HANDLERS: Set up bidirectional service communication
    
    // Service Servers: ROS network -> ROS handlers -> LogicModule
{%- for interface in args.ros.interfaces if interface.type == "service" and interface.direction == "out" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type,
                           cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
    // Connect {{ interface.name }} service server from ROS to LogicModule
    if (service_handler_) {
        service_handler_->set_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_callback(
            [this](const std::shared_ptr<{{ lu.ros_data_type }}::Request> request,
                   std::shared_ptr<{{ lu.ros_data_type }}::Response> response) {
                logic_module_.service_handler().process_service_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(request, response);
            });
    }
    {%- endif %}
{%- endfor %}
    
    // Service Clients: LogicModule -> ROS handlers -> ROS network
{%- for interface in args.ros.interfaces if interface.type == "service" and interface.direction == "in" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set msg_entry = args.lookup.interfaces.msgs[interface.msgs] %}
    {%- set lu = namespace(
            ros_data_type = msg_entry.ros_data_type,
            request_fields = msg_entry.cpp_data_type.req if msg_entry.cpp_data_type.req is defined else [],
            response_fields = msg_entry.cpp_data_type.res if msg_entry.cpp_data_type.res is defined else []
        ) %}
    // Connect {{ interface.name }} service client from LogicModule to ROS
    logic_module_.service_handler().set_service_call_callback_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
        [this](const std::shared_ptr<{{ lu.ros_data_type }}::Request> request) {
            if (!service_handler_) {
                RCLCPP_WARN(this->get_logger(), "Service handler not initialized for {{ interface.name }}");
                return;
            }
            if (!request) {
                RCLCPP_WARN(this->get_logger(), "Service call {{ interface.name }} received null request");
                return;
            }
            auto response = std::make_shared<{{ lu.ros_data_type }}::Response>();
            {%- set call_args = [] %}
            {%- for field in lu.request_fields %}
            {%- set _ = call_args.append("request->" ~ field.name) %}
            {%- endfor %}
            {%- for field in lu.response_fields %}
            {%- set _ = call_args.append("response->" ~ field.name) %}
            {%- endfor %}
            bool call_success = service_handler_->call_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
{%- if call_args %}
                {{ call_args | join(',\n                ') }}
{%- endif %}
            );
            if (!call_success) {
                RCLCPP_WARN(this->get_logger(), "Service call {{ interface.name }} failed to dispatch");
                return;
            }
            logic_module_.service_handler().handle_service_response_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(response);
        });
    {%- endif %}
{%- endfor %}
    
    // 3. ACTION HANDLERS: Set up bidirectional action communication
    
    // Action Servers: ROS network -> ROS handlers -> LogicModule
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "out" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type) %}
    // Connect {{ interface.name }} action server from ROS to LogicModule
    if (action_handler_) {
        action_handler_->set_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_callbacks(
            // Goal callback (accept by default)
            [this](const rclcpp_action::GoalUUID & /*uuid*/, 
                   std::shared_ptr<const {{ lu.ros_data_type }}::Goal> /*goal*/) -> rclcpp_action::GoalResponse {
                return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
            },
            // Cancel callback (acknowledge cancel requests)
            [this](const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ lu.ros_data_type }}>> /*goal_handle*/) -> rclcpp_action::CancelResponse {
                return rclcpp_action::CancelResponse::ACCEPT;
            },
            // Accepted callback
            [this](const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ lu.ros_data_type }}>> goal_handle) {
                if (!goal_handle) {
                    RCLCPP_WARN(this->get_logger(), "Received null goal handle for {{ interface.name }}");
                    return;
                }
                // Execute action in LogicModule on a background thread
                std::thread([this, goal_handle]() {
                    auto feedback = std::make_shared<{{ lu.ros_data_type }}::Feedback>();
                    auto result = std::make_shared<{{ lu.ros_data_type }}::Result>();

                    logic_module_.action_handler().execute_action_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
                        goal_handle->get_goal(),
                        feedback,
                        result,
                        [goal_handle]() -> bool { return goal_handle->is_canceling(); },
                        [goal_handle](std::shared_ptr<{{ lu.ros_data_type }}::Feedback> feedback_msg) {
                            if (!goal_handle->is_canceling() && feedback_msg) {
                                goal_handle->publish_feedback(feedback_msg);
                            }
                        },
                        [this]() -> bool { return rclcpp::ok(); });

                    if (goal_handle->is_canceling()) {
                        goal_handle->canceled(result);
                    } else {
                        goal_handle->succeed(result);
                    }
                }).detach();
            });
    }
    {%- endif %}
{%- endfor %}
    
    // Action Clients: LogicModule -> ROS handlers -> ROS network
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "in" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(
            cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type,
            ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type) %}
    {%- if lu.cpp_data_type.goal is defined %}
    // Connect {{ interface.name }} action client from LogicModule to ROS
    logic_module_.action_handler().set_action_callback_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
        [this](
        {%- for field in lu.cpp_data_type.goal %}
        const {{ field.type }} &goal_{{ field.name }}{% if not loop.last %}, {% endif %}
        {%- endfor %}) {
            if (!action_handler_) {
                RCLCPP_WARN(this->get_logger(), "Action handler not initialized for {{ interface.name }}");
                return;
            }
            bool dispatched = action_handler_->send_goal_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
            {%- for field in lu.cpp_data_type.goal %}
                goal_{{ field.name }}{% if not loop.last %}, {% endif %}
            {%- endfor %}
            );
            if (!dispatched) {
                RCLCPP_WARN(this->get_logger(), "Failed to dispatch action goal for {{ interface.name }}");
            }
        });
    {%- endif %}
    {%- endif %}
{%- endfor %}
    
    // 4. PARAMETER HANDLERS: Set up parameter synchronization
{%- set parameter_ns = namespace(items=[]) %}
{%- for interface in args.ros.interfaces if interface.type == "parameter" and interface.direction == "in" %}
    {%- set _ = parameter_ns.items.append(interface) %}
{%- endfor %}
{%- if parameter_ns.items %}
    if (parameter_handler_) {
        parameter_handler_->set_parameter_change_callback(
            [this](const std::string& param_name, const rclcpp::Parameter& param) {
                bool handled = false;
{%- for interface in parameter_ns.items %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type) %}
                if (param_name == "{{ interface.name }}") {
                    handled = true;
        {%- for field in lu.cpp_data_type %}
            {%- if field.type == "std::string" %}
                    if (param.get_type() == rclcpp::ParameterType::PARAMETER_STRING) {
                        logic_module_.parameter_handler().process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(param.as_string());
                    } else {
                        RCLCPP_WARN(this->get_logger(), "Parameter '%s' expected string but received different type", param_name.c_str());
                    }
            {%- elif field.type == "double" %}
                    if (param.get_type() == rclcpp::ParameterType::PARAMETER_DOUBLE) {
                        logic_module_.parameter_handler().process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(param.as_double());
                    } else {
                        RCLCPP_WARN(this->get_logger(), "Parameter '%s' expected double but received different type", param_name.c_str());
                    }
            {%- elif field.type == "int" or field.type == "int32_t" %}
                    if (param.get_type() == rclcpp::ParameterType::PARAMETER_INTEGER) {
                        logic_module_.parameter_handler().process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(param.as_int());
                    } else {
                        RCLCPP_WARN(this->get_logger(), "Parameter '%s' expected integer but received different type", param_name.c_str());
                    }
            {%- elif field.type == "bool" %}
                    if (param.get_type() == rclcpp::ParameterType::PARAMETER_BOOL) {
                        logic_module_.parameter_handler().process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(param.as_bool());
                    } else {
                        RCLCPP_WARN(this->get_logger(), "Parameter '%s' expected bool but received different type", param_name.c_str());
                    }
            {%- else %}
                    logic_module_.parameter_handler().process_parameter_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(param.value_to_string());
            {%- endif %}
        {%- endfor %}
                }
    {%- endif %}
{%- endfor %}
                if (!handled) {
                    RCLCPP_WARN(this->get_logger(), "Received update for unhandled parameter '%s'", param_name.c_str());
                }
            });
    }
{%- endif %}
{%- endif %}
{%- endif %}

    RCLCPP_INFO(this->get_logger(), "Logic module initialization completed with handler delegation");
}

/****************** Parameter Access Methods ******************/
/// @brief Function to get all private parameters of a node
/// @return private_params
std::vector<RosParam> ROSNode::get_private_parameters()
{
    std::vector<RosParam> private_params;
    
    auto parameter_names = this->list_parameters({}, 0);
    
    for (const auto& param_name : parameter_names.names)
    {
        RosParam buffer;
        buffer.name = param_name;
        
        // Get the parameter value
        auto param = this->get_parameter(param_name);
        buffer.value = param.value_to_string();
        
        private_params.push_back(buffer);
    }

    return private_params;
}

/// @brief Function to set a private parameter
/// @param param_name 
/// @param param_value 
/// @return True if the parameter was set successfully, false otherwise
bool ROSNode::set_private_parameter(const std::string& param_name, const std::string& param_value) {
    // Check if the parameter name is valid
    if (param_name.empty() || param_value.empty()) {
        RCLCPP_ERROR_STREAM(this->get_logger(), "Invalid parameter name or value");
        return false;
    }

    try {
        // Set the parameter in ROS2 - this will trigger parameter callbacks
        this->set_parameter(rclcpp::Parameter(param_name, param_value));
        RCLCPP_INFO_STREAM(this->get_logger(), "Private parameter set: " << param_name << " = " << param_value);
        return true;
    } catch (const std::exception& e) {
        RCLCPP_ERROR_STREAM(this->get_logger(), "Failed to set private parameter: " << param_name << " - " << e.what());
        return false;
    }
}

} // namespace {{ args.package.name|regex_replace('[^A-Za-z0-9]', '_') }}
