#pragma once

#include "base_interface_handler.hpp"
#include <rclcpp_action/rclcpp_action.hpp>
#include <functional>

{#- Initialize an empty list to collect unique message types #}
{%- set unique_msgs = [] %}
{%- if args.ros is defined %}
{%- if args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "action" %}
{#- Check if the message type is already in the list #}
{%- if interface.msgs not in unique_msgs -%}
{#- If not, add it to the list #}
{%- set unique_msgs = unique_msgs.append(interface.msgs) -%}
{%- endif -%}
{%- endfor %}
{%- endif %}
{%- endif %}

{%- for msgs in unique_msgs|sort %}
{%- if msgs in args.lookup.interfaces.msgs %}
{%- set lu = namespace(include=args.lookup.interfaces.msgs[msgs].include) %}
#include "{{ lu.include }}.hpp"
{%- else %}
// implementation is required for msgs: {{ msgs }}
{%- endif %}
{%- endfor %}

namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}} {

/**
 * @brief Abstract interface for action handlers
 * 
 * Provides delegation interface for both action servers and clients
 */
class ActionHandler : public BaseInterfaceHandler {
public:
    explicit ActionHandler(rclcpp::Node* node) : BaseInterfaceHandler(node) {}
    virtual ~ActionHandler() = default;

{%- if args.ros is defined %}
{%- if args.ros.interfaces is defined %}
    // === Action client interface methods ===
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "in" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(cpp_data_type = args.lookup.interfaces.msgs[interface.msgs].cpp_data_type,
                           ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type) %}
    /**
     * @brief Send goal to {{ interface.name }} action server
     * @param {{ interface.description }}
     */
    virtual bool send_goal_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}(
    {%- if lu.cpp_data_type.goal is defined %}
    {%- for field in lu.cpp_data_type.goal %}
        const {{ field.type }} &goal_{{ field.name }}{% if not loop.last %}, {% endif %}
    {%- endfor %}
    {%- else %}
        const {{ lu.ros_data_type }}::Goal &goal
    {%- endif %}) = 0;

    /**
     * @brief Cancel goal for {{ interface.name }} action
     */
    virtual bool cancel_goal_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}() = 0;
    {%- endif %}
{%- endfor %}

    // === Action server callback registration ===
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "out" %}
    {%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
    {%- set lu = namespace(ros_data_type = args.lookup.interfaces.msgs[interface.msgs].ros_data_type) %}
    /**
     * @brief Set callbacks for {{ interface.name }} action server
     * @param goal_callback Function to handle goal requests: {{ interface.description }}
     * @param cancel_callback Function to handle cancel requests
     */
    virtual void set_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}_callbacks(
        std::function<rclcpp_action::GoalResponse(const rclcpp_action::GoalUUID &, 
                                                 std::shared_ptr<const {{ lu.ros_data_type }}::Goal>)> goal_callback,
        std::function<rclcpp_action::CancelResponse(const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ lu.ros_data_type }}>>)> cancel_callback,
        std::function<void(const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ lu.ros_data_type }}>>)> accepted_callback) = 0;
    {%- endif %}
{%- endfor %}
{%- endif %}
{%- endif %}
};

} // namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}