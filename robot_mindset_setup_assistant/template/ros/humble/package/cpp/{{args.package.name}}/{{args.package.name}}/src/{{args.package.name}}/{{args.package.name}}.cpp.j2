#include "{{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}/{{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}.hpp"

/**
 * @file {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}.cpp
 * @brief LogicModule implementation using composition and delegation
 *
 * The LogicModule keeps non-ROS business logic consolidated while deferring
 * interface-specific behavior to dedicated handler classes:
 * - TopicHandler for publish/subscribe flows
 * - ServiceHandler for request/response cycles
 * - ActionHandler for goal execution and client interactions
 * - ParameterHandler for runtime configuration changes
 *
 * Each handler is responsible for the detailed Jinja-preserved sections that
 * developers customize. This file holds common utilities (for example the
 * sample greet/spdlog functions) and shared configuration helpers such as
 * logger management.
 */

namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}
{

LogicModule::LogicModule() {
    spdlog::info("LogicModule initialized with composition pattern");
    spdlog::debug("Handlers initialized: TopicHandler, ServiceHandler, ActionHandler, ParameterHandler");
}

std::string LogicModule::greet(const std::string& name) const {
    fmt::print("This is a non-ROS module.\n");

    return fmt::format("Hello, {}! This is a non-ROS module.", name);
}

void LogicModule::spdlog_test(double number) const {
    spdlog::info("Welcome to spdlog version {}.{}.{}  !", SPDLOG_VER_MAJOR, SPDLOG_VER_MINOR,
        SPDLOG_VER_PATCH);

    spdlog::warn("My float {:03.2f}", number);

    spdlog::warn("Easy padding in numbers like {:08d}", 12);
    spdlog::critical("Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}", 42);
    spdlog::info("Support for floats {:03.2f}", 1.23456);
    spdlog::info("Positional args are {1} {0}..", "too", "supported");
    spdlog::info("{:>8} aligned, {:<8} aligned", "right", "left");
}

void LogicModule::set_logger_level(std::string level_str)
{
    // to lower case
    std::transform(level_str.begin(), level_str.end(), level_str.begin(), ::tolower);
    // Set the logger level based on the provided string
    if (level_str == "debug")
    {
        spdlog::set_level(spdlog::level::debug);
        spdlog::info("Log level set to debug");
    }
    else if (level_str == "info")
    {
        spdlog::set_level(spdlog::level::info);
        spdlog::info("Log level set to info");
    }
    else if (level_str == "warn")
    {
        spdlog::set_level(spdlog::level::warn);
        spdlog::info("Log level set to warn");
    }
    else if (level_str == "error")
    {
        spdlog::set_level(spdlog::level::err);       // spdlog::err is equivalent to error
        spdlog::info("Log level set to error");
    }
    else if (level_str == "fatal")
    {
        spdlog::set_level(spdlog::level::critical);  // Mapping fatal to critical
        spdlog::info("Log level set to critical");
    }
    else
    {
        spdlog::set_level(spdlog::level::info);      // Default fallback level
        spdlog::warn("Invalid log level provided ({}). Defaulting to info level.", level_str);
    }
}

}
