#include "{{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}/{{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}.hpp"

/**
 * @file {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}.cpp
 * @brief LogicModule implementation using composition and delegation pattern
 * 
 * This file contains the core business logic implementation, separated from
 * ROS-specific code for better testability and maintainability.
 * 
 * ARCHITECTURE:
 * The LogicModule uses composition and delegation to organize interface handling:
 * - TopicHandler: Manages all topic-related business logic
 * - ServiceHandler: Manages all service-related business logic  
 * - ActionHandler: Manages all action-related business logic
 * - ParameterHandler: Manages all parameter-related business logic
 * 
 * This provides better organization, testability, and maintainability compared
 * to having all interface logic mixed in a single class.
 * 
 * DELEGATION PATTERN:
 * The LogicModule implements the interface methods but delegates the actual
 * business logic to the appropriate specialized handlers. This maintains
 * backward compatibility while providing better internal organization.
 * 
 * =============================================================================
 * ROS ACTION SERVER INTERFACE DESCRIPTION
 * =============================================================================
 * 
 * This LogicModule implements action server execution methods that handle the
 * core business logic for ROS action servers. The ROS node delegates action
 * execution to these methods, providing a clean separation between ROS
 * infrastructure and business logic.
 * 
 * ACTION SERVER EXECUTION PATTERN:
 * --------------------------------
 * 1. ROS node receives action goal
 * 2. ROS node calls LogicModule::execute_action_*() method
 * 3. LogicModule implements business logic using provided callbacks
 * 4. ROS node handles final result (success/canceled/aborted)
 * 
 * AVAILABLE ACTION SERVERS:
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "out" %}
{%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
{%- set lu = args.lookup.interfaces.msgs[interface.msgs] %}
 * - {{ interface.name }} ({{ lu.ros_data_type }})
 *   Description: {{ interface.description }}
 *   Method: execute_action_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}()
{%- endif %}
{%- endfor %}
{%- endif %}
 * 
 * ACTION SERVER METHOD SIGNATURE:
 * -------------------------------
 * void execute_action_<name>(
 *     const std::shared_ptr<const ActionType::Goal> goal,        // Input: Goal parameters
 *     std::shared_ptr<ActionType::Feedback> feedback,           // Output: Progress updates
 *     std::shared_ptr<ActionType::Result> result,               // Output: Final result
 *     std::function<bool()> is_canceling,                       // Callback: Check cancellation
 *     std::function<void(std::shared_ptr<Feedback>)> publish_feedback, // Callback: Send feedback
 *     std::function<bool()> is_ok                               // Callback: Check ROS status
 * )
 * 
 * IMPLEMENTATION GUIDELINES:
 * -------------------------
 * 1. Use is_canceling() regularly to check for cancellation requests
 * 2. Use publish_feedback(feedback) to send progress updates to clients
 * 3. Use is_ok() to check if ROS is still running (e.g., in loops)
 * 4. Set result values before returning
 * 5. Return early if is_canceling() returns true
 * 6. Use JINJA preservation tags to preserve custom implementations
 * 
 * =============================================================================
 * ROS ACTION CLIENT INTERFACE DESCRIPTION
 * =============================================================================
 * 
 * This LogicModule also implements action client interface methods that can be
 * called to trigger action client requests to external action servers.
 * 
 * ACTION CLIENT USAGE PATTERN:
 * ----------------------------
 * 1. Your business logic calls interface_act_*() method
 * 2. LogicModule calls the ROS layer callback to send goal
 * 3. ROS layer handles goal sending, feedback, and results
 * 4. ROS layer calls LogicModule callback methods for responses
 * 
 * AVAILABLE ACTION CLIENTS:
{%- if args.ros is defined and args.ros.interfaces is defined %}
{%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "in" %}
{%- if args.lookup.interfaces.msgs[interface.msgs] is defined %}
{%- set lu = args.lookup.interfaces.msgs[interface.msgs] %}
 * - {{ interface.name }} ({{ lu.ros_data_type }})
 *   Description: {{ interface.description }}
 *   Trigger: interface_act_{{ interface.name|regex_replace('[^A-Za-z0-9]', '_') }}()
 *   Callbacks: goal_response_callback_*, feedback_callback_*, result_callback_*
{%- endif %}
{%- endfor %}
{%- endif %}
 * 
 * ACTION CLIENT CALLBACK METHODS (Override these in your LogicModule):
 * -------------------------------------------------------------------
 * - goal_response_callback_<name>(): Called when goal is accepted/rejected
 * - feedback_callback_<name>(): Called when feedback is received from server
 * - result_callback_<name>(): Called when final result is received
 * 
 * =============================================================================
 */

namespace {{ args.package.name |regex_replace('[^A-Za-z0-9]', '_')}}
{

LogicModule::LogicModule() {
    spdlog::info("LogicModule initialized with composition pattern");
    spdlog::debug("Handlers initialized: TopicHandler, ServiceHandler, ActionHandler, ParameterHandler");
}

std::string LogicModule::greet(const std::string& name) const {
    fmt::print("This is a non-ROS module.\n");

    return fmt::format("Hello, {}! This is a non-ROS module.", name);
}

void LogicModule::spdlog_test(double number) const {
    spdlog::info("Welcome to spdlog version {}.{}.{}  !", SPDLOG_VER_MAJOR, SPDLOG_VER_MINOR,
        SPDLOG_VER_PATCH);

    spdlog::warn("My float {:03.2f}", number);

    spdlog::warn("Easy padding in numbers like {:08d}", 12);
    spdlog::critical("Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}", 42);
    spdlog::info("Support for floats {:03.2f}", 1.23456);
    spdlog::info("Positional args are {1} {0}..", "too", "supported");
    spdlog::info("{:>8} aligned, {:<8} aligned", "right", "left");
}

void LogicModule::set_logger_level(std::string level_str)
{
    // to lower case
    std::transform(level_str.begin(), level_str.end(), level_str.begin(), ::tolower);
    // Set the logger level based on the provided string
    if (level_str == "debug")
    {
        spdlog::set_level(spdlog::level::debug);
        spdlog::info("Log level set to debug");
    }
    else if (level_str == "info")
    {
        spdlog::set_level(spdlog::level::info);
        spdlog::info("Log level set to info");
    }
    else if (level_str == "warn")
    {
        spdlog::set_level(spdlog::level::warn);
        spdlog::info("Log level set to warn");
    }
    else if (level_str == "error")
    {
        spdlog::set_level(spdlog::level::err);       // spdlog::err is equivalent to error
        spdlog::info("Log level set to error");
    }
    else if (level_str == "fatal")
    {
        spdlog::set_level(spdlog::level::critical);  // Mapping fatal to critical
        spdlog::info("Log level set to critical");
    }
    else
    {
        spdlog::set_level(spdlog::level::info);      // Default fallback level
        spdlog::warn("Invalid log level provided ({}). Defaulting to info level.", level_str);
    }
}

}
