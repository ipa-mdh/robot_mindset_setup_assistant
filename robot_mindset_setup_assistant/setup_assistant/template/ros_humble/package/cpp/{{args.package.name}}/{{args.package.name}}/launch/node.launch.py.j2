import os
from pathlib import Path
import yaml
from loguru import logger

import launch
import launch_ros
from ament_index_python.packages import get_package_share_directory

def generate_standard_launch_description():
    """
    Generate a standard launch description.
    """
    logger.info("---- {{args.package.name}}/node.launch -----")
    # Set default launch arguments
    namespace = launch.substitutions.LaunchConfiguration('namespace', default='{{args.package.name}}')
    simulation = launch.substitutions.LaunchConfiguration('simulation', default='true')
    simulation_with_gazebo = launch.substitutions.LaunchConfiguration('simulation_with_gazebo', default='false')
    gazebo_classic = launch.substitutions.LaunchConfiguration('gazebo_classic', default='true')

    # get path of package
    package_path = Path(get_package_share_directory('{{args.package.name}}'))

    default_instance_config = package_path / 'example' / 'instance_config' / '{{args.package.name}}'
    instance_config_folder = launch.substitutions.LaunchConfiguration('instance_config_folder', default=str(default_instance_config.as_posix()))

    return [
        launch.actions.DeclareLaunchArgument('namespace', default_value=namespace),
        launch.actions.DeclareLaunchArgument('simulation', default_value=simulation),
        launch.actions.DeclareLaunchArgument('simulation_with_gazebo', default_value=simulation_with_gazebo),
        launch.actions.DeclareLaunchArgument('gazebo_classic', default_value=gazebo_classic),
        launch.actions.DeclareLaunchArgument('instance_config_folder', default_value=instance_config_folder),
    ]

def get_config(config_file: Path):
    config = {}
    
    if config_file.exists():
        with open(config_file, 'r') as f:
            config = yaml.safe_load(f)
    else:
        logger.warning(f"Config file {config_file} does not exist. Using empty config.")
    
    # if key config is not in config
    if 'config' not in config:
        logger.warning(f"Key 'config' not found in config file. Using empty config.")
        return {}
    else:
        return config['config']

def generate_custom_launch_description(context, *args, **kwargs):
    """
    Generate a custom launch description.
    """
    namespace = launch.substitutions.LaunchConfiguration('namespace').perform(context)
    simulation = launch.substitutions.LaunchConfiguration('simulation').perform(context)
    simulation_with_gazebo = launch.substitutions.LaunchConfiguration('simulation_with_gazebo').perform(context)
    gazebo_classic = launch.substitutions.LaunchConfiguration('gazebo_classic').perform(context)

    instance_config_folder = Path(launch.substitutions.LaunchConfiguration('instance_config_folder').perform(context))

    gz = simulation and simulation_with_gazebo

    launch_description = []


    # --------------------------------------------
    #             package related code
    # --------------------------------------------
    config = get_config(instance_config_folder / "config.yaml")

    # --- Robot description ---
    robot_description_content = launch.substitutions.Command(
        [
            launch.substitutions.PathJoinSubstitution([launch.substitutions.FindExecutable(name="xacro")]),
            " ",launch.substitutions.PathJoinSubstitution(
                [
                    # todo: use robot fanuc package
                    launch_ros.substitutions.FindPackageShare("crx_description"),
                    "urdf",
                    "crx10ia_l",
                    "crx10ia_l"+".xacro"
                ]),
            " ", "use_mock_hardware:=", str(config.get('use_mock_hardware', 'false')),
            " ", "robot_type:=", str(config.get('robot_type', 'crx10ia_l')),
            " ", "robot_ip:=", str(config.get('robot_ip', '192.168.1.100')),
            " ", "read_only:=", str(config.get('read_only', 'false')),
            " ", "use_rmi:=", str(config.get('use_rmi', 'false')),
            " ", "use_hspo:=", str(config.get('use_hspo', 'false')),
            " ", "gz:=", gz
        ]
    )

    robot_description = {"robot_description": robot_description_content}

    # --- Robot controllers --- 
    controllers_file = instance_config_folder / config.get('controllers_file', 'controllers.yaml')
    launch_description.append(launch_ros.actions.Node(
        package="controller_manager",
        executable="ros2_control_node",
        parameters=[robot_description, controllers_file],
        remappings=[
            (
                "/forward_position_controller/commands",
                "/position_commands",
            ),
        ],
        output="both",
    ))

    # active controllers
    launch_description.append(launch_ros.actions.Node(
            package="controller_manager",
            executable="spawner",
            arguments=["manipulator_controller",
                       "--controller-manager", "controller_manager"],
        )
    )

    # inactive controllers
    launch_description.append(launch_ros.actions.Node(
            package="controller_manager",
            executable="spawner",
            arguments=["--inactive",
                       "forward_position_controller",
                       "--controller-manager", "controller_manager"],
        )
    )

    # --- joint state publisher --- 
    launch_description.append(launch_ros.actions.Node(
            package="controller_manager",
            executable="spawner",
            arguments=["joint_state_broadcaster",
                       "--controller-manager", "controller_manager"],
        )
    )

    # --------------------------------------------
    #  ~~~~~~~~~~ package related code ~~~~~~~~~~
    # --------------------------------------------

    return launch_description

def generate_launch_description():
    buffer = []
    buffer = generate_standard_launch_description()
    buffer.append(launch.actions.OpaqueFunction(function=generate_custom_launch_description))
    return launch.LaunchDescription(buffer)

if __name__ == '__main__':
    generate_launch_description()