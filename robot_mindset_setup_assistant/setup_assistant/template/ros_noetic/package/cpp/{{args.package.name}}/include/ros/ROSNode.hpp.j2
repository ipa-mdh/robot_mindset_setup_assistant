/*
 * This file is auto-generated using Jinja2.
 * It creates a ROS node with the specified topics, services, and actions.
 */

#pragma once
#include <string>
#include <ros/ros.h>

{#- Initialize an empty list to collect unique message types #}
{%- set unique_msgs = [] %}
{%- set ns = namespace(add_actionlib=false) -%}

{%- for interface in args.ros.interfaces %}
    {#- Check if the message type is already in the list #}
    {%- if interface.msgs not in unique_msgs -%}
        {#- If not, add it to the list #}
        {%- set unique_msgs = unique_msgs.append(interface.msgs) -%}
    {%- endif -%}

    {#- Check if the interface is an action and set the flag #}
    {%- if interface.type == "action" -%}
        {%- set ns.add_actionlib = true -%}
    {%- endif -%}
{%- endfor %}

// Include message headers based on the Robot Rindest Setup Assistant configuration
{%- if ns.add_actionlib %}
#include <actionlib/server/simple_action_server.h>
#include <actionlib/client/simple_action_client.h>
{% endif %}

{%- for msgs in unique_msgs|sort %}
#include "{{ msgs.split('/')[0] }}/{{ msgs.split('/')[1] }}.h"
{%- endfor %}

namespace {{args.package.name}} {

    class ROSNode
    {
    public:
      ROSNode(ros::NodeHandle &nh)
      {
        // Initialize topics
        {%- for interface in args.ros.interfaces if interface.type == "topic" %}
          {%- if interface.direction == "in" %}
        // Topic subscriber for: {{ interface.description }}
        sub_{{ interface.name }} = nh.subscribe("{{ interface.name }}", 10, &ROSNode::intern_callback_{{ interface.name }}, this);
          {%- elif interface.direction == "out" %}
        // Topic publisher for: {{ interface.description }}
        pub_{{ interface.name }} = nh.advertise<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}>("{{ interface.name }}", 10);
          {%- endif %}
        {%- endfor %}
    
        // Initialize services
        {%- for interface in args.ros.interfaces if interface.type == "service" %}
          {%- if interface.direction == "server" %}
        // Service server for: {{ interface.description }}
        srv_{{ interface.name }} = nh.advertiseService("{{ interface.name }}", &ROSNode::intern_callback_{{ interface.name }}, this);
          {%- elif interface.direction == "client" %}
        // Service client for: {{ interface.description }}
        srv_client_{{ interface.name }} = nh.serviceClient<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}>("{{ interface.name }}");
          {%- endif %}
        {%- endfor %}
    
        // Initialize actions
        {%- for interface in args.ros.interfaces if interface.type == "action" %}
          {%- if interface.direction == "server" %}
        // Action server for: {{ interface.description }}
        as_{{ interface.name }} = new actionlib::SimpleActionServer<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}>(nh, "{{ interface.name }}",
                                    boost::bind(&ROSNode::execute_{{ interface.name }}, this, _1), false);
        as_{{ interface.name }}->start();
          {%- elif interface.direction == "client" %}
        // Action client for: {{ interface.description }}
        ac_{{ interface.name }} = new actionlib::SimpleActionClient<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}>("{{ interface.name }}", true);
          {%- endif %}
        {%- endfor %}
      }
    
      ~ROSNode()
      {
        {#–– Delete dynamically allocated action servers/clients ––#}
        {%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction in ["server", "client"] %}
        delete {{ 'as_' if interface.direction == "server" else 'ac_' }}{{ interface.name }};
        {%- endfor %}
      }
    
      /****************** Setter Methods for External Callbacks ******************/
    
      {#–– Setter for topic subscriber callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
      void set_callback_{{ interface.name }}(const std::function<void(const {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::ConstPtr &)> &cb)
      {
        callback_{{ interface.name }} = cb;
      }
      {%- endfor %}
    
      {#–– Setter for service server callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "service" and interface.direction == "server" %}
      void set_callback_{{ interface.name }}(const std::function<bool(typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Request &, typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Response &)> &cb)
      {
        service_callback_{{ interface.name }} = cb;
      }
      {%- endfor %}
    
      {#–– Setter for action server callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "server" %}
      void set_callback_{{ interface.name }}(const std::function<void(const typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::GoalConstPtr &)> &cb)
      {
        action_callback_{{ interface.name }} = cb;
      }
      {%- endfor %}
    
      /****************** Internal Callback Functions ******************/
    
      // Topic subscriber callbacks
      {%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
      void intern_callback_{{ interface.name }}(const {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::ConstPtr &msg)
      {
        ROS_INFO("Received on topic {{ interface.name }}");
        {#–– If an external callback is provided, invoke it; otherwise do nothing (or default processing) ––#}
        if (callback_{{ interface.name }})
        {
          callback_{{ interface.name }}(msg);
        }
      }
      {%- endfor %}
    
      // Service server callbacks
      {%- for interface in args.ros.interfaces if interface.type == "service" and interface.direction == "server" %}
      bool intern_callback_{{ interface.name }}(typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Request &req, typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Response &res)
      {
        ROS_INFO("Service {{ interface.name }} called");
        if (service_callback_{{ interface.name }})
        {
          return service_callback_{{ interface.name }}(req, res);
        }
        {#–– Default implementation for AddTwoInts service ––#}
        {%- if "AddTwoInts" in interface.msgs %}
        res.sum = req.a + req.b;
        ROS_INFO("Default AddTwoInts: a=%ld, b=%ld, sum=%ld", req.a, req.b, res.sum);
        {%- endif %}
        return true;
      }
      {%- endfor %}
    
      // Action server callbacks
      {%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "server" %}
      void execute_{{ interface.name }}(const typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::GoalConstPtr &goal)
      {
        ROS_INFO("Action server {{ interface.name }} received a goal");
        if (action_callback_{{ interface.name }})
        {
          action_callback_{{ interface.name }}(goal);
          return;
        }
        {#–– Default dummy implementation for the action server ––#}
        ros::Rate r(1);
        int count = 0;
        typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Feedback feedback;
        typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Result result;
    
        while (ros::ok() && count < 5)
        {
          if (as_{{ interface.name }}->isPreemptRequested())
          {
            ROS_INFO("Action {{ interface.name }} preempted");
            as_{{ interface.name }}->setPreempted();
            return;
          }
          feedback.current_state = count;  // Assumes field 'current_state' exists in Feedback
          as_{{ interface.name }}->publishFeedback(feedback);
          r.sleep();
          count++;
        }
        result.final_state = count;  // Assumes field 'final_state' exists in Result
        as_{{ interface.name }}->setSucceeded(result);
      }
      {%- endfor %}
    
    private:
      /****************** External Callback Storage ******************/
    
      {#–– For topic subscriber callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "topic" and interface.direction == "in" %}
      std::function<void(const {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::ConstPtr &)> callback_{{ interface.name }};
      {%- endfor %}
    
      {#–– For service server callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "service" and interface.direction == "server" %}
      std::function<bool(typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Request &, typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::Response &)> service_callback_{{ interface.name }};
      {%- endfor %}
    
      {#–– For action server callbacks ––#}
      {%- for interface in args.ros.interfaces if interface.type == "action" and interface.direction == "server" %}
      std::function<void(const typename {{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}::GoalConstPtr &)> action_callback_{{ interface.name }};
      {%- endfor %}
    
      /****************** Interface Members ******************/
    
      // Topic interfaces: subscribers and publishers
      {%- for interface in args.ros.interfaces if interface.type == "topic" %}
        {%- if interface.direction == "in" %}
      ros::Subscriber sub_{{ interface.name }};
        {%- elif interface.direction == "out" %}
      ros::Publisher pub_{{ interface.name }};
        {%- endif %}
      {%- endfor %}
    
      // Service interfaces: servers and clients
      {%- for interface in args.ros.interfaces if interface.type == "service" %}
        {%- if interface.direction == "server" %}
      ros::ServiceServer srv_{{ interface.name }};
        {%- elif interface.direction == "client" %}
      ros::ServiceClient srv_client_{{ interface.name }};
        {%- endif %}
      {%- endfor %}
    
      // Action interfaces: servers and clients (using dynamic allocation)
      {%- for interface in args.ros.interfaces if interface.type == "action" %}
        {%- if interface.direction == "server" %}
      actionlib::SimpleActionServer<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}> *as_{{ interface.name }};
        {%- elif interface.direction == "client" %}
      actionlib::SimpleActionClient<{{ interface.msgs.split('/')[0] }}::{{ interface.msgs.split('/')[1] }}> *ac_{{ interface.name }};
        {%- endif %}
      {%- endfor %}
    };

}